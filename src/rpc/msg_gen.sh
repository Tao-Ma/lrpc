#! /bin/sh
# Copyright (C) Tao Ma(tao.ma.1984@gmail.com), All rights reserved.
# https://github.com/Tao-Ma/rpc/

pkgname=
outfile=
protofile=

while [ $# -gt 0 ]; do
	case $1 in
		--input|-i)
			shift
			protofile=$1
			;;
		--output|-o)
			shift
			outfile=$1
			;;
		--pkgname|-n)
			shift
			pkgname=$1
			;;
		*)
			echo "invalid argument: \"$1\"" >&2
			exit 1
			;;
	esac
	shift
done

if [ -z "$pkgname" ]; then
	echo "invalid package name: \"$pkgname\"" >&2
	exit 1
fi

echo "generate new protobuf file..."
protoc --go_out="." "$protofile"  || exit $?

names=`grep message "$protofile" | awk '{print $2}' | grep -E -v '^[[:blank:]]*$'`

# header
cat >"$outfile" <<EOF
// Generated by rpc/msg_gen.sh

package $pkgname

import (
	mi "rpc/msg_interface"
	"github.com/golang/protobuf/proto"
)

const (
	_ = iota
EOF

# Output the msg id
for n in $names
do
	echo "	${n}ID" >> "$outfile"
done

cat >>"$outfile" <<EOF
)

type msgProtobufFactory struct{}

func NewMsgProtobufFactory() mi.MsgPayloadFactory {
	pf := new(msgProtobufFactory)
	return mi.MsgPayloadFactory(pf)
}

type msgProtobufBuffer struct {
	buf proto.Buffer
}

func (pf *msgProtobufFactory) NewBuffer() mi.MsgPayloadBuffer{
	pb := new(msgProtobufBuffer)

	return mi.MsgPayloadBuffer(pb)
}

func (pb *msgProtobufBuffer) Marshal(p mi.MsgPayload, b []byte) ([]byte, error) {
	// Refer: github.com/golang/protobuf/proto/encode.go
	// func Marshal(pb Message) ([]byte, error)
	m, ok := p.(proto.Message)
	if !ok {
		// TODO: error
		return nil, nil
	}

	pb.buf.SetBuf(b)
	pb.buf.Reset()
	err := pb.buf.Marshal(m)
	if err != nil {
		return nil, err
	}

	return pb.buf.Bytes(), nil
}

func (pb *msgProtobufBuffer) Unmarshal(id uint16, b []byte) (mi.MsgPayload, error) {
	p := pb.New(id)
	m, ok := p.(proto.Message)
	if !ok {
		// TODO: error
		return nil, nil
	}

	pb.buf.SetBuf(b)
	if err := pb.buf.Unmarshal(m); err != nil {
		return nil, err
	} else {
		return p, nil
	}
}

func (pb *msgProtobufBuffer) New(id uint16) (p mi.MsgPayload) {
	switch id {
EOF

for n in $names
do
	cat >> "$outfile" << EOF
	case ${n}ID:
		p = New${n}()
EOF
done

cat >> "$outfile" << EOF
	}

	return p
}

EOF

for n in $names
do
	cat >>"$outfile" << EOF
func New${n}() *${n} {
	return new(${n})
}

func (p *${n}) GetMsgPayloadID() uint16 {
	return ${n}ID
}
EOF
done

