#! /bin/sh
# Copyright (C) Tao Ma(tao.ma.1984@gmail.com), All rights reserved.
# https://github.com/Tao-Ma/rpc/

pkgname=rpc
outfile=msg_pbpayload.go
outpath=.
protofile=msg.proto

echo "generate new protobuf file..."
protoc --go_out="$outpath" "$protofile"  || exit $?

names=`grep message "$protofile" | awk '{print $2}' | grep -E -v '^[[:blank:]]*$'`

# header
cat >"$outfile" <<EOF
// Generated by rpc/msg_gen.sh

package $pkgname

import (
	"github.com/golang/protobuf/proto"
)

const (
	_ = iota
EOF

# Output the msg id
for n in $names
do
	echo "\t${n}ID" >> "$outfile"
done

cat >>"$outfile" <<EOF
)

type protobufFactory struct{}

func NewProtobufFactory() MsgPayloadFactory {
	pf := new(protobufFactory)
	return MsgPayloadFactory(pf)
}

type protobufBufferFactory struct {
	buf proto.Buffer
}

func (pf *protobufFactory) NewBufferFactory() MsgPayloadBufferFactory {
	pbf := new(protobufBufferFactory)

	return MsgPayloadBufferFactory(pbf)
}

func (pbf *protobufBufferFactory) Marshal(p MsgPayload, b []byte) ([]byte, error) {
	// Refer: github.com/golang/protobuf/proto/encode.go
	// func Marshal(pb Message) ([]byte, error)
	m, ok := p.(proto.Message)
	if !ok {
		// TODO: error
		return nil, nil
	}

	pbf.buf.SetBuf(b)
	pbf.buf.Reset()
	err := pbf.buf.Marshal(m)
	if err != nil {
		return nil, err
	}

	return pbf.buf.Bytes(), nil
}

func (pbf *protobufBufferFactory) Unmarshal(id uint16, b []byte) (MsgPayload, error) {
	p := pbf.New(id)
	m, ok := p.(proto.Message)
	if !ok {
		// TODO: error
		return nil, nil
	}

	pbf.buf.SetBuf(b)
	if err := pbf.buf.Unmarshal(m); err != nil {
		return nil, err
	} else {
		return p, nil
	}
}

func (pbf *protobufBufferFactory) New(id uint16) (p MsgPayload) {
	switch id {
EOF

for n in $names
do
	cat >> "$outfile" << EOF
	case ${n}ID:
		p = New${n}()
EOF
done

cat >> "$outfile" << EOF
	}

	return p
}

EOF

for n in $names
do
	cat >>"$outfile" << EOF
func New${n}() *${n} {
	return new(${n})
}

func (p *${n}) GetMsgPayloadID() uint16 {
	return ${n}ID
}
EOF
done

